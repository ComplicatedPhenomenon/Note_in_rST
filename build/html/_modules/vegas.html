
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>vegas &#8212; Woody 0.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for vegas</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Introduction</span>
<span class="sd">--------------------</span>
<span class="sd">This package provides tools for estimating multidimensional</span>
<span class="sd">integrals numerically using an enhanced version of</span>
<span class="sd">the adaptive Monte Carlo |vegas| algorithm (G. P. Lepage,</span>
<span class="sd">J. Comput. Phys. 27(1978) 192).</span>

<span class="sd">A |vegas| code generally involves two objects, one representing</span>
<span class="sd">the integrand and the other representing an integration</span>
<span class="sd">operator for a particular multidimensional volume. A typical</span>
<span class="sd">code sequence for a D-dimensional integral has the structure::</span>

<span class="sd">    # create the integrand</span>
<span class="sd">    def f(x):</span>
<span class="sd">        ... compute the integrand at point x[d] d=0,1...D-1</span>
<span class="sd">        ...</span>

<span class="sd">    # create an integrator for volume with</span>
<span class="sd">    # xl0 &lt;= x[0] &lt;= xu0, xl1 &lt;= x[1] &lt;= xu1 ...</span>
<span class="sd">    integration_region = [[xl0, xu0], [xl1, xu1], ...]</span>
<span class="sd">    integrator = vegas.Integrator(integration_region)</span>

<span class="sd">    # do the integral and print out the result</span>
<span class="sd">    result = integrator(f, nitn=10, neval=10000)</span>
<span class="sd">    print(result)</span>

<span class="sd">The algorithm iteratively adapts to the integrand over</span>
<span class="sd">``nitn`` iterations, each of which uses at most ``neval``</span>
<span class="sd">integrand samples to generate a Monte Carlo estimate of</span>
<span class="sd">the integral. The final result is the weighted average</span>
<span class="sd">of the results from all iterations. Increase ``neval``</span>
<span class="sd">to increase the precision of the result. Typically</span>
<span class="sd">``nitn`` is between 10 and 20. ``neval`` can be</span>
<span class="sd">1000s to millions, or more, depending upon</span>
<span class="sd">the integrand and the precision desired.</span>

<span class="sd">The integrator remembers how it adapted to ``f(x)``</span>
<span class="sd">and uses this information as its starting point if it is reapplied</span>
<span class="sd">to ``f(x)`` or applied to some other function ``g(x)``.</span>
<span class="sd">An integrator&#39;s state can be archived for future applications</span>
<span class="sd">using Python&#39;s :mod:`pickle` module.</span>

<span class="sd">See the extensive Tutorial in the first section of the |vegas| documentation.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Created by G. Peter Lepage (Cornell University) in 12/2013.</span>
<span class="c1"># Copyright (c) 2013-17 G. Peter Lepage.</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># any later version (see &lt;http://www.gnu.org/licenses/&gt;).</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>

<span class="kn">from</span> <span class="nn">._vegas</span> <span class="k">import</span> <span class="n">RAvg</span><span class="p">,</span> <span class="n">RAvgArray</span><span class="p">,</span> <span class="n">RAvgDict</span>
<span class="kn">from</span> <span class="nn">._vegas</span> <span class="k">import</span> <span class="n">AdaptiveMap</span><span class="p">,</span> <span class="n">Integrator</span><span class="p">,</span> <span class="n">BatchIntegrand</span>
<span class="kn">from</span> <span class="nn">._vegas</span> <span class="k">import</span> <span class="n">reporter</span><span class="p">,</span> <span class="n">batchintegrand</span>
<span class="kn">from</span> <span class="nn">._vegas</span> <span class="k">import</span> <span class="n">MPIintegrand</span>
<span class="kn">from</span> <span class="nn">._version</span> <span class="k">import</span> <span class="n">version</span> <span class="k">as</span> <span class="n">__version__</span>
<span class="c1"># legacy names:</span>
<span class="kn">from</span> <span class="nn">._vegas</span> <span class="k">import</span> <span class="n">vecintegrand</span><span class="p">,</span> <span class="n">VecIntegrand</span>

<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">_gvar</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>

<div class="viewcode-block" id="PDFIntegrator"><a class="viewcode-back" href="../vegas.html#vegas.PDFIntegrator">[docs]</a><span class="k">class</span> <span class="nc">PDFIntegrator</span><span class="p">(</span><span class="n">Integrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; :mod:`vegas` integrator for PDF expectation values.</span>

<span class="sd">    ``PDFIntegrator(g)`` is a :mod:`vegas` integrator that evaluates</span>
<span class="sd">    expectation values for the multi-dimensional Gaussian distribution</span>
<span class="sd">    specified by with ``g``, which is a |GVar| or an array of |GVar|\s or a</span>
<span class="sd">    dictionary whose values are |GVar|\s or arrays of |GVar|\s.</span>

<span class="sd">    ``PDFIntegrator`` integrates over the entire parameter space of the</span>
<span class="sd">    distribution but reexpresses integrals in terms of variables</span>
<span class="sd">    that diagonalize ``g``&#39;s covariance matrix and are centered at</span>
<span class="sd">    its mean value. This greatly facilitates integration over these</span>
<span class="sd">    variables using the :mod:`vegas` module, making integrals over</span>
<span class="sd">    10s or more of parameters feasible.</span>

<span class="sd">    A simple illustration of ``PDFIntegrator`` is given by the following</span>
<span class="sd">    code::</span>

<span class="sd">        import vegas</span>
<span class="sd">        import gvar as gv</span>

<span class="sd">        # multi-dimensional Gaussian distribution</span>
<span class="sd">        g = gv.BufferDict()</span>
<span class="sd">        g[&#39;a&#39;] = gv.gvar([0., 1.], [[1., 0.9], [0.9, 1.]])</span>
<span class="sd">        g[&#39;b&#39;] = gv.gvar(&#39;1(1)&#39;)</span>

<span class="sd">        # integrator for expectation values in distribution g</span>
<span class="sd">        g_expval = vegas.PDFIntegrator(g)</span>

<span class="sd">        # want expectation value of [fp, fp**2]</span>
<span class="sd">        def f_f2(p):</span>
<span class="sd">            fp = p[&#39;a&#39;][0] * p[&#39;a&#39;][1] + p[&#39;b&#39;]</span>
<span class="sd">            return [fp, fp ** 2]</span>

<span class="sd">        # adapt integrator to f_f2</span>
<span class="sd">        warmup = g_expval(f_f2, neval=1000, nitn=5)</span>

<span class="sd">        # &lt;f_f2&gt; in distribution g</span>
<span class="sd">        results = g_expval(f_f2, neval=1000, nitn=5, adapt=False)</span>
<span class="sd">        print(results.summary())</span>
<span class="sd">        print(&#39;results =&#39;, results, &#39;\\n&#39;)</span>

<span class="sd">        # mean and standard deviation of f(p)&#39;s distribution</span>
<span class="sd">        fmean = results[0]</span>
<span class="sd">        fsdev = gv.sqrt(results[1] - results[0] ** 2)</span>
<span class="sd">        print (&#39;f.mean =&#39;, fmean, &#39;   f.sdev =&#39;, fsdev)</span>
<span class="sd">        print (&quot;Gaussian approx&#39;n for f(g) =&quot;, f_f2(g)[0])</span>

<span class="sd">    where the ``warmup`` calls to the integrator are used to adapt it to</span>
<span class="sd">    the integrand, and the final results are in ``results``. Here ``neval`` is</span>
<span class="sd">    the (approximate) number of function calls per iteration of the</span>
<span class="sd">    :mod:`vegas` algorithm and ``nitn`` is the number of iterations. We</span>
<span class="sd">    use the integrator to calculated  the expectation value of ``fp`` and</span>
<span class="sd">    ``fp**2``, so we can compute the standard deviation for the</span>
<span class="sd">    distribution of ``fp``\s. The output from this code shows that the</span>
<span class="sd">    Gaussian approximation (1.0(1.4)) for the mean and standard deviation</span>
<span class="sd">    of the ``fp`` distribution is not particularly accurate here</span>
<span class="sd">    (correct value is 1.9(2.0)), because of the large uncertainties in</span>
<span class="sd">    ``g``::</span>

<span class="sd">        itn   integral        average         chi2/dof        Q</span>
<span class="sd">        -------------------------------------------------------</span>
<span class="sd">          1   1.893(38)       1.893(38)           0.00     1.00</span>
<span class="sd">          2   1.905(35)       1.899(26)           0.25     0.78</span>
<span class="sd">          3   1.854(41)       1.884(22)           0.47     0.76</span>
<span class="sd">          4   1.921(36)       1.893(19)           0.44     0.85</span>
<span class="sd">          5   1.913(37)       1.897(17)           0.35     0.94</span>

<span class="sd">        results = [1.897(17) 7.48(10)]</span>

<span class="sd">        f.mean = 1.897(17)    f.sdev = 1.969(21)</span>
<span class="sd">        Gaussian approx&#39;n for f(g) = 1.0(1.4)</span>

<span class="sd">    In general functions being integrated can return a number, or an array of</span>
<span class="sd">    numbers, or a dictionary whose values are numbers or arrays of numbers.</span>
<span class="sd">    This allows multiple expectation values to be evaluated simultaneously.</span>

<span class="sd">    See the documentation with the :mod:`vegas` module for more details on its</span>
<span class="sd">    use, and on the attributes and methods associated with integrators.</span>
<span class="sd">    The example above sets ``adapt=False`` when  computing final results. This</span>
<span class="sd">    gives more reliable error estimates  when ``neval`` is small. Note</span>
<span class="sd">    that ``neval`` may need to be much larger (tens or hundreds of</span>
<span class="sd">    thousands) for more difficult high-dimension integrals.</span>

<span class="sd">    Args:</span>
<span class="sd">        g : |GVar|, array of |GVar|\s, or dictionary whose values</span>
<span class="sd">            are |GVar|\s or arrays of |GVar|\s that specifies the</span>
<span class="sd">            multi-dimensional Gaussian distribution used to construct</span>
<span class="sd">            the probability density function.</span>

<span class="sd">        limit (positive float): Limits the integrations to a finite</span>
<span class="sd">            region of size ``limit`` times the standard deviation on</span>
<span class="sd">            either side of the mean. This can be useful if the</span>
<span class="sd">            functions being integrated misbehave for large parameter</span>
<span class="sd">            values (e.g., ``numpy.exp`` overflows for a large range of</span>
<span class="sd">            arguments). Default is ``1e15``.</span>

<span class="sd">        scale (positive float): The integration variables are</span>
<span class="sd">            rescaled to emphasize parameter values of order</span>
<span class="sd">            ``scale`` times the standard deviation. The rescaling</span>
<span class="sd">            does not change the value of the integral but it</span>
<span class="sd">            can reduce uncertainties in the :mod:`vegas` estimate.</span>
<span class="sd">            Default is ``1.0``.</span>

<span class="sd">        svdcut (non-negative float or None): If not ``None``, replace</span>
<span class="sd">            covariance matrix of ``g`` with a new matrix whose</span>
<span class="sd">            small eigenvalues are modified: eigenvalues smaller than</span>
<span class="sd">            ``svdcut`` times the maximum eigenvalue ``eig_max`` are</span>
<span class="sd">            replaced by ``svdcut*eig_max``. This can ameliorate</span>
<span class="sd">            problems caused by roundoff errors when inverting the</span>
<span class="sd">            covariance matrix. It increases the uncertainty associated</span>
<span class="sd">            with the modified eigenvalues and so is conservative.</span>
<span class="sd">            Setting ``svdcut=None`` or ``svdcut=0`` leaves the</span>
<span class="sd">            covariance matrix unchanged. Default is ``1e-15``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">1e15</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">PDF</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">g</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span> <span class="o">=</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">PDF</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">svdcut</span><span class="o">=</span><span class="n">svdcut</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">if</span> <span class="n">kargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;sync_ran&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="c1"># needed because of the Monte Carlo in _make_map()</span>
            <span class="n">Integrator</span><span class="o">.</span><span class="n">synchronize_random</span><span class="p">()</span>   <span class="c1"># for mpi</span>
        <span class="n">integ_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PDFIntegrator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="p">[</span><span class="n">integ_map</span><span class="p">],</span> <span class="o">**</span><span class="n">kargs</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Make vegas grid that is adapted to the pdf. &quot;&quot;&quot;</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="mi">2000</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">ny</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">limit</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">AdaptiveMap</span><span class="p">([[</span><span class="o">-</span><span class="n">limit</span><span class="p">,</span> <span class="n">limit</span><span class="p">]],</span> <span class="n">ninc</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">itn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="n">m</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">jac</span><span class="p">)</span>
            <span class="n">tan_theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">tan_theta</span>
            <span class="n">fx</span> <span class="o">=</span> <span class="p">(</span><span class="n">tan_theta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">add_training_data</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">jac</span> <span class="o">*</span> <span class="n">fx</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<div class="viewcode-block" id="PDFIntegrator.__call__"><a class="viewcode-back" href="../vegas.html#vegas.PDFIntegrator.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nopdf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_fstd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Estimate expectation value of function ``f(p)``.</span>

<span class="sd">        Uses module :mod:`vegas` to estimate the integral of</span>
<span class="sd">        ``f(p)`` multiplied by the probability density function</span>
<span class="sd">        associated with ``g`` (i.e., ``pdf(p)``). The probability</span>
<span class="sd">        density function is omitted if ``nopdf=True`` (default</span>
<span class="sd">        setting is ``False``).</span>

<span class="sd">        Args:</span>
<span class="sd">            f (function): Function ``f(p)`` to integrate. Integral is</span>
<span class="sd">                the expectation value of the function with respect</span>
<span class="sd">                to the distribution. The function can return a number,</span>
<span class="sd">                an array of numbers, or a dictionary whose values are</span>
<span class="sd">                numbers or arrays of numbers.</span>

<span class="sd">            nopdf (bool): If ``True`` drop the probability density function</span>
<span class="sd">                from the integrand (so no longer an expectation value).</span>
<span class="sd">                This is useful if one wants to use the optimized</span>
<span class="sd">                integrator for something other than a standard</span>
<span class="sd">                expectation value (e.g., an expectation value with a</span>
<span class="sd">                non-Gaussian PDF). Default is ``False``.</span>

<span class="sd">        All other keyword arguments are passed on to a :mod:`vegas`</span>
<span class="sd">        integrator; see the :mod:`vegas` documentation for further information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nopdf</span> <span class="ow">and</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;nopdf==True and f is None =&gt; no integrand&#39;</span><span class="p">)</span>
        <span class="n">integrand</span> <span class="o">=</span> <span class="n">batchintegrand</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_expval</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nopdf</span><span class="p">))</span> <span class="c1"># fstd, nopdf))</span>
        <span class="n">results</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">PDFIntegrator</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results</span></div>

    <span class="k">def</span> <span class="nf">_expval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">nopdf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return integrand using the tan mapping. &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">ff</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">nopdf</span><span class="o">=</span><span class="n">nopdf</span><span class="p">):</span>
            <span class="n">tan_theta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="n">tan_theta</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">*</span> <span class="p">(</span><span class="n">tan_theta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nopdf</span><span class="p">:</span>
                <span class="n">pdf</span> <span class="o">=</span> <span class="n">jac</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">pjac</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pdf</span> <span class="o">=</span> <span class="n">jac</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">x2dpflat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">parg</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">fparg_is_dict</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># iterate through the batch</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">pdfi</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span> <span class="n">pdf</span><span class="p">)):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">meanflat</span> <span class="o">+</span> <span class="n">dpi</span>
                <span class="k">if</span> <span class="n">parg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># first time only</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">extend</span><span class="p">:</span>
                            <span class="n">parg</span> <span class="o">=</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">ExtendedDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">parg</span> <span class="o">=</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">g</span><span class="p">,</span> <span class="n">buf</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parg</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parg</span><span class="o">.</span><span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">parg</span><span class="o">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">p</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">parg</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">p</span>
                <span class="n">fparg</span> <span class="o">=</span> <span class="mf">1.</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">f</span><span class="p">(</span><span class="n">parg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># first time only</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fparg</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">):</span>
                        <span class="n">fparg_is_dict</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fparg</span><span class="p">,</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">):</span>
                            <span class="n">fparg</span> <span class="o">=</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">(</span><span class="n">fparg</span><span class="p">)</span>
                        <span class="n">ans</span> <span class="o">=</span> <span class="n">_gvar</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fparg</span><span class="p">:</span>
                            <span class="n">ans</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">),)</span> <span class="o">+</span> <span class="n">fparg</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">float</span>
                                <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fparg</span><span class="p">)</span> <span class="o">==</span> <span class="p">():</span>
                            <span class="n">ans</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ans</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                                <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pdf</span><span class="p">),)</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fparg</span><span class="p">),</span> <span class="nb">float</span>
                                <span class="p">)</span>
                <span class="k">if</span> <span class="n">fparg_is_dict</span><span class="p">:</span>
                    <span class="n">prod_pdfi</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pdfi</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">:</span>
                        <span class="n">ans</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fparg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">ans</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">prod_pdfi</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fparg</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">fparg</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fparg</span><span class="p">)</span>
                    <span class="n">ans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fparg</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pdfi</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ans</span>
        <span class="k">return</span> <span class="n">ff</span></div>

<span class="k">class</span> <span class="nc">parallelintegrand</span><span class="p">(</span><span class="n">BatchIntegrand</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Convert (batch) integrand into multiprocessor integrand.</span>

<span class="sd">    Usage::</span>

<span class="sd">        fparallel = vegas.parallelintegrand(fbatch, 4)</span>

<span class="sd">    turns batch integrand ``fbatch`` into multi-process integrand</span>
<span class="sd">    that spreads integrand evaluations over 4 processes. The original</span>
<span class="sd">    integrand ``fbatch`` needs to be defined at the top level</span>
<span class="sd">    of the Python script and should return a :mod:`numpy` array.</span>

<span class="sd">    This is *not* part of the public API.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">nproc</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="s2">&quot; Save integrand; create pool of nproc processes. &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fcn</span> <span class="o">=</span> <span class="n">fcn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">nproc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nproc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot; Standard cleanup. &quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot; Divide x into self.nproc chunks, feeding one to each process. &quot;</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nproc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># launch evaluation of self.fcn for each chunk, in parallel</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fcn</span><span class="p">,</span>
            <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">nx</span> <span class="p">:</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nx</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nproc</span><span class="p">)],</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># convert list of results into a single numpy array</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Pixar.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>