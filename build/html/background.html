
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>How vegas Works &#8212; Woody 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="vegas Module" href="vegas.html" />
    <link rel="prev" title="Tutorial" href="tutorial.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="how-vegas-works">
<h1>How <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Works<a class="headerlink" href="#how-vegas-works" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> uses two adaptive strategies: importance sampling, and
adaptive stratified sampling. Here we discuss the ideas behind each,
in turn.</p>
<div class="section" id="importance-sampling">
<h2>Importance Sampling<a class="headerlink" href="#importance-sampling" title="Permalink to this headline">¶</a></h2>
<p>The most important adaptive strategy <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> uses is
its remapping of the integration variables in each
direction, before it makes Monte Carlo estimates of the integral.
This is equivalent to a standard Monte Carlo optimization
called “importance sampling.”</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> chooses transformations
for each integration variable
that minimize the statistical errors in
Monte Carlo estimates whose integrand
samples are uniformly distributed
in the new variables.
The idea in one-dimension, for
example, is to replace the original integral over <span class="math notranslate">\(x\)</span>,</p>
<div class="math notranslate">
\[I = \int_a^b dx\; f(x),\]</div>
<p>by an equivalent integral over a new variable <span class="math notranslate">\(y\)</span>,</p>
<div class="math notranslate">
\[I = \int_0^1 dy\; J(y)\; f(x(y)),\]</div>
<p>where <span class="math notranslate">\(J(y)\)</span> is the Jacobian of the transformation.
A simple Monte Carlo estimate of the transformed
integral is given by</p>
<div class="math notranslate">
\[I \approx S^{(1)} \equiv \frac{1}{M} \sum_y \;J(y)\; f(x(y))\]</div>
<p>where the sum is over <span class="math notranslate">\(M\)</span> random points
uniformly distributed between 0 and 1.</p>
<p>The estimate <span class="math notranslate">\(S^{(1)}\)</span> is a itself a random number from a distribution
whose mean is the exact integral and whose variance is:</p>
<div class="math notranslate">
\[\begin{split}\sigma_I^2 &amp;= \frac{1}{M}\left(
\int_0^1 dy\; J^2(y) \; f^2(x(y)) - I^2
\right) \\
&amp;= \frac{1}{M}\left(
\int_a^b dx \;J(y(x))\; f^2(x) - I^2
\right)\end{split}\]</div>
<p>The standard deviation <span class="math notranslate">\(\sigma_I\)</span> is an estimate of the possible
error in the Monte Carlo estimate.
A straightforward variational calculation, constrained by</p>
<div class="math notranslate">
\[\int_a^b \frac{dx}{J(y(x))} = \int_0^1 dy = 1,\]</div>
<p>shows that <span class="math notranslate">\(\sigma_I\)</span> is minimized if</p>
<div class="math notranslate">
\[J(y(x)) = \frac{\int_a^b dx\;|f(x)|}{|f(x)|}.\]</div>
<p>Such transformations greatly reduce the standard deviation when the
integrand has high peaks. Since</p>
<div class="math notranslate">
\[1/J = \frac{dy}{dx} \propto |f(x)|,\]</div>
<p>the regions in <span class="math notranslate">\(x\)</span> space where <span class="math notranslate">\(|f(x)|\)</span> is large are
stretched out in <span class="math notranslate">\(y\)</span> space. Consequently, a uniform Monte Carlo in <span class="math notranslate">\(y\)</span> space
places more samples in the peak regions than it would
if were we integrating in <span class="math notranslate">\(x\)</span> space — its samples are concentrated
in the most important regions, which is why this is called “importance
sampling.” The product <span class="math notranslate">\(J(y)\;f(x(y))\)</span> has no peaks when
the transformation is optimal.</p>
<p>The distribution of the Monte Carlo estimates <span class="math notranslate">\(S^{(1)}\)</span> becomes
Gaussian in the limit of large <span class="math notranslate">\(M\)</span>. Non-Gaussian corrections
vanish like <span class="math notranslate">\(1/M\)</span>. For example, it is easy to show that</p>
<div class="math notranslate">
\[\langle (S^{(1)} - I) ^ 4 \rangle
=
3\sigma_I^4\left( 1 - \frac{1}{M}\right)
+ \frac{1}{M^3} \int_0^1 dy \;
(J(y)\;f(x(y)) - I)^4\]</div>
<p>This moment would equal <span class="math notranslate">\(3\sigma_I^4\)</span>, which falls like <span class="math notranslate">\(1/M^2\)</span>,
if the distribution was Gaussian. The corrections to the Gaussian result
fall as <span class="math notranslate">\(1/M^3\)</span> and so become negligible at large <span class="math notranslate">\(M\)</span>.
These results assume
that <span class="math notranslate">\((J(y)\:f(x(y)))^n\)</span> is integrable for all <span class="math notranslate">\(n\)</span>,
which need not be the case
if <span class="math notranslate">\(f(x)\)</span> has (integrable) singularities.</p>
</div>
<div class="section" id="the-vegas-grid">
<h2>The <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> Grid<a class="headerlink" href="#the-vegas-grid" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> implements the transformation of an integration variable
<span class="math notranslate">\(x\)</span> into a new variable <span class="math notranslate">\(y\)</span> using a grid in <span class="math notranslate">\(x\)</span> space:</p>
<blockquote>
<div><div class="math notranslate">
\[\begin{split}x_0 &amp;= a \\
x_1 &amp;= x_0 + \Delta x_0 \\
x_2 &amp;= x_1 + \Delta x_1 \\
\cdots \\
x_N &amp;= x_{N-1} + \Delta x_{N-1} = b\end{split}\]</div>
</div></blockquote>
<p>The grid specifies the transformation function at the points
<span class="math notranslate">\(y=i/N\)</span> for <span class="math notranslate">\(i=0,1\ldots N\)</span>:</p>
<blockquote>
<div><div class="math notranslate">
\[x(y\!=\!i/N) = x_i\]</div>
</div></blockquote>
<p>Linear interpolation is used between those points.
The Jacobian for this transformation function is piecewise constant:</p>
<blockquote>
<div><div class="math notranslate">
\[J(y) = J_i = N \Delta x_i\]</div>
</div></blockquote>
<p>for <span class="math notranslate">\(i/N &lt; y &lt; (i+1)/N\)</span>.</p>
<p>The variance for a Monte Carlo estimate using this transformation
becomes</p>
<div class="math notranslate">
\[\sigma_I^2 = \frac{1}{M}\left(
\sum_i J_i \int_{x_i}^{x_{i+1}} dx \; f^2(x) - I^2
\right)\]</div>
<p>Treating the <span class="math notranslate">\(J_i\)</span> as independent variables, with the
constraint</p>
<div class="math notranslate">
\[\sum_i \frac{\Delta x_i}{J_i} = \sum_i \Delta y_i = 1,\]</div>
<p>it is trivial to show that the standard deviation is minimized
when</p>
<div class="math notranslate">
\[\frac{J_i^2}{\Delta x_i}
\int_{x_i}^{x_{i+1}} dx \; f^2(x)
= N^2 \Delta x_i \int_{x_i}^{x_{i+1}} dx \; f^2(x)
\; = \; \mbox{constant}\]</div>
<p>for all <span class="math notranslate">\(i\)</span>.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adjusts the grid until this last condition is
satisfied.  As a result grid increments <span class="math notranslate">\(\Delta x_i\)</span> are
small in regions where <span class="math notranslate">\(|f(x)|\)</span> is large.
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> typically has no knowledge of the integrand initially, and
so starts with a uniform <span class="math notranslate">\(x\)</span> grid. As it samples the integrand
it also estimates the integrals</p>
<div class="math notranslate">
\[\int_{x_i}^{x_{i+1}} dx \; f^2(x),\]</div>
<p>and use this information to refine
its choice of <span class="math notranslate">\(\Delta x_i\)</span>s, bringing them closer to their optimal
values, for use
in subsequent iterations. The grid usually converges,
after several iterations,
to the optimal grid.</p>
<p>This analysis generalizes easily to multi-dimensional integrals.
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> applies a similar transformation in each direction, and
the grid increments along an axis
are made smaller in regions where the
projection of the integral onto that axis is larger. For example,
the optimal grid for the four-dimensional Gaussian integral
in the previous section looks like:</p>
<a class="reference internal image-reference" href="_images/eg1a-plt1.png"><img alt="_images/eg1a-plt1.png" src="_images/eg1a-plt1.png" style="width: 80%;" /></a>
<a class="reference internal image-reference" href="_images/eg1a-plt2.png"><img alt="_images/eg1a-plt2.png" src="_images/eg1a-plt2.png" style="width: 80%;" /></a>
<p>These grids transform into uniformly-spaced grids in <span class="math notranslate">\(y\)</span> space.
Consequently a uniform, <span class="math notranslate">\(y\)</span>-space Monte Carlo places the same
number of integrand evaluations, on average, in every rectangle
of these pictures. (The average number is typically much less one
in higher dimensions.) Integrand evaluations are concentrated
in regions where the <span class="math notranslate">\(x\)</span>-space rectangles are small
(and therefore numerous) —
here in the vicinity of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">[0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.5,</span> <span class="pre">0.5]</span></code>, where the
peak is.</p>
<p>These plots were obtained by including the line</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">integ</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">show_grid</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
</pre></div>
</div>
<p>in the integration code after the integration is finished.
It causes <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> (if it is installed) to create
images showing the locations of 30 nodes
of
the grid in each direction. (The grid uses 99 nodes in all
on each axis, but that is too many to display at low resolution.)</p>
</div>
<div class="section" id="adaptive-stratified-sampling">
<h2>Adaptive Stratified Sampling<a class="headerlink" href="#adaptive-stratified-sampling" title="Permalink to this headline">¶</a></h2>
<p>A limitation of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s remapping strategy becomes obvious if we look
at the grid for the following integral, which has two Gaussians
arranged along the diagonal of the hypercube:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">vegas</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1013.2167575422921535</span>
    <span class="n">dx2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">dx2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">ans</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dx2</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1013.2167575422921535</span>
    <span class="k">return</span> <span class="n">ans</span> <span class="o">/</span> <span class="mf">2.</span>

<span class="n">integ</span> <span class="o">=</span> <span class="n">vegas</span><span class="o">.</span><span class="n">Integrator</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">integ</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">4e4</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">integ</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mf">4e4</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result = </span><span class="si">%s</span><span class="s1">    Q = </span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">Q</span><span class="p">))</span>

<span class="n">integ</span><span class="o">.</span><span class="n">map</span><span class="o">.</span><span class="n">show_grid</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>
</pre></div>
</div>
<p>This code gives the following grid, now showing 70 nodes
in each direction:</p>
<a class="reference internal image-reference" href="_images/eg1h-plt1.png"><img alt="_images/eg1h-plt1.png" src="_images/eg1h-plt1.png" style="width: 80%;" /></a>
<p>The grid shows that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> is concentrating on the regions
around <code class="docutils literal notranslate"><span class="pre">x=[0.33,</span> <span class="pre">0.33,</span> <span class="pre">0.33,</span> <span class="pre">0.33]</span></code> and
<code class="docutils literal notranslate"><span class="pre">x=[0.67,</span> <span class="pre">0.67,</span> <span class="pre">0.67,</span> <span class="pre">0.67]</span></code>, where the peaks are.
Unfortunately it is also concentrating on regions around
points like <code class="docutils literal notranslate"><span class="pre">x=[0.67,</span> <span class="pre">0.33,</span> <span class="pre">0.33,</span> <span class="pre">0.33]</span></code> where the integrand
is very close to zero. There are 14 such phantom peaks
that <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s new integration variables emphasize,
in addition to the 2 regions
where the integrand actually is large. This grid gives
much better results
than using a uniform grid, but it obviously
wastes integration resources.
The waste occurs because
<a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> remaps the integration variables in
each direction separately. Projected on the <code class="docutils literal notranslate"><span class="pre">x[0]</span></code> axis, for example,
this integrand appears to have two peaks and so <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> will
focus on both regions of <code class="docutils literal notranslate"><span class="pre">x[0]</span></code>, independently of what it does
along the <code class="docutils literal notranslate"><span class="pre">x[1]</span></code> axis.</p>
<p><a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> uses axis-oriented remappings because other
alternatives are much more complicated and expensive; and <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s
principal adaptive strategy has proven very effective in
many realistic applications.</p>
<p>An axis-oriented
strategy will always have difficulty adapting to structures that
lie along diagonals of the integration volume. To address such problems,
the new version of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> introduces a second adaptive strategy,
based upon another standard Monte Carlo technique called “stratified
sampling.” <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> divides the <span class="math notranslate">\(d\)</span>-dimensional
<span class="math notranslate">\(y\)</span>-space volume into <span class="math notranslate">\(M_\mathrm{st}^d\)</span> hypercubes using
a uniform <span class="math notranslate">\(y\)</span>-space grid with <span class="math notranslate">\(M_\mathrm{st}\)</span> stratifications on each
axis. It estimates
the integral by doing a separate Monte Carlo integration in each of
the hypercubes, and adding the results together to provide an estimate
for the integral over the entire integration region.
Typically
this <span class="math notranslate">\(y\)</span>-space grid is much coarser than the <span class="math notranslate">\(x\)</span>-space grid used to
remap the integration variables. This is because <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> needs
at least two integrand evaluations in each <span class="math notranslate">\(y\)</span>-space hypercube, and
so must keep the number of hypercubes <span class="math notranslate">\(M_\mathrm{st}^d\)</span> smaller than <code class="docutils literal notranslate"><span class="pre">neval/2</span></code>.
This can restrict <span class="math notranslate">\(M_\mathrm{st}\)</span> severely when <span class="math notranslate">\(d\)</span> is large.</p>
<p>Older versions of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> also divide <span class="math notranslate">\(y\)</span>-space into hypercubes and
do Monte Carlo estimates in the separate hypercubes. These versions, however,
use the same number of integrand evaluations in each hypercube.
In the new version, <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> adjusts the number of evaluations used
in a hypercube in proportion to the standard deviation of
the integrand estimates (in <span class="math notranslate">\(y\)</span> space) from that hypercube.
It uses information about the hypercube’s standard deviation in one
iteration to set the number of evaluations for that hypercube
in the next iteration. In this way it concentrates
integrand evaluations where the potential statistical errors are
largest.</p>
<p>In the two-Gaussian example above, for example,
the new <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> shifts
integration evaluations away from the phantom peaks, into
the regions occupied by the real peaks since this is where all
the error comes from. This improves <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a>’s ability to estimate
the contributions from the real peaks and
reduces statistical errors,
provided <code class="docutils literal notranslate"><span class="pre">neval</span></code> is large enough to permit a large number  (more
than 2 or 3) <span class="math notranslate">\(M_\mathrm{st}\)</span> of
stratifications on each axis. With <code class="docutils literal notranslate"><span class="pre">neval=4e4</span></code>,
statistical errors for the two-Gaussian
integral are reduced by more than a factor of 3 relative to what older
versions of <a class="reference internal" href="vegas.html#module-vegas" title="vegas: Adaptive multidimensional Monte Carlo integration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code></a> give. This is a relatively easy integral;
the difference can be much larger for more difficult (and realistic)
integrals.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">How <code class="docutils literal notranslate"><span class="pre">vegas</span></code> Works</a><ul>
<li><a class="reference internal" href="#importance-sampling">Importance Sampling</a></li>
<li><a class="reference internal" href="#the-vegas-grid">The <code class="docutils literal notranslate"><span class="pre">vegas</span></code> Grid</a></li>
<li><a class="reference internal" href="#adaptive-stratified-sampling">Adaptive Stratified Sampling</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="tutorial.html" title="previous chapter">Tutorial</a></li>
      <li>Next: <a href="vegas.html" title="next chapter"><code class="docutils literal notranslate"><span class="pre">vegas</span></code> Module</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/background.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Pixar.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/background.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>